 long 和 float类型的定义 数据值后面需要加L/F  long a = 100L;  float b = 10.1F;<br>

   
键盘输入 cin-- <br>
import java.util.Scanner; // 这是java写好的键盘键入的包<br>
public class scanner{
     public static void main(String[] args){
       // 创建对象
          Scanner sc = new Scanner(System.in);
       // 接收数据
          int i = sc.nextInt();
          System.out.println(i);
     }
}

* 字符串（是String 不是 char）参与的+ 会把字符串相加  例如  "abc" + 123 = "abc123";     1 + 2 + "abc" + 2 + 1 = "3abc21"  有字符串参与的+是字符串加法， 而1+2没有字符串

稀疏数组 用一个array[n][3]的二维数组存，其中array[i][0]代表横坐标 array[i][1]代表纵坐标 array[i][2]代表值

面向对象：
三大特性： 封装，继承，多态
static的方法不需要实例化对象就能调用方法，而非静态方法需要实例化对象再进行调用
static和类一起加载的，而非static是类实例化后才存在的

写了有参构造，那么就没有无参构造，这样子子类调用父类无参构造时会出问题，所以最好在写有参构造前先写无参构造。
封装：属性私有， get/set
super:当子类重复定义父类的属性时，那么用this得到子类的属性,用super得到父类的属性。
super注意点:
1.super调用父类的构造方法，必须在构造方法的第一个
2.super 必须只能出现在子类的方法或者构造方法中!
3.super和 this 不能同时调用构造方法!
Vs this:
 代表的对象不同:
    this: 本身调用者这个对象super: 代表父类对象的应用
 前提
    没有继承也可以使用this:super: 只能在继承条件才可以使用构造方法
    this() ;本类的构造super(): 父类的构造!
重写：需要有继承关系，子类重写父类的方法！   重写和重载不同！！！
在Java中，静态成员（包括静态方法和静态变量）是与类关联而不是与实例关联的。当一个类继承另一个类时，它会继承父类的实例成员（非静态成员），但不会继承父类的静态成员。
1.方法名必须相同
2.参数列表必须相同
3.修饰符：范围可以扩大：   public>protected>private
4.抛出的异常:范围，可以被缩小，但不能扩大
多态：
多态是方法的多态，属性没有多态
一个对象的实际类型是确定的  例如 new Student()， 但引用类型是不确定的 例如 People p = new Student()

对象的实例只能由父类或者子类引用
父类引用子类实例，可以调用所有父类的方法，当子类对父类的方法进行重写后，则调用子类重写后的方法。
static private final的方法都不能多态，static是因为不是实例，private是因为不能继承
/*
1.父类引用指向子类的对象
2.把子类转换为父类，向上转型
3.把父类转换为子类，向下转型； 强制转换
4.方便方法的调用，减少重复的代码！
*/




String类：
1.字符串比较 
String s1 = new String("abc")
String s2 = "abc";
System.out.println(a==b) False    ==用于比较时 基本数据类型比较的是数据集 如char int double boolean等， 引用数据类型比较的是地址值
那么字符串如何进行比较呢？ boolean equals     boolean equalslgnoreCase  前者是比较是否完全相等  后者忽略大小写
用法 s1.equals(s2)  s1.equalslgnoreCase(s2)  返回boolean
2.字符串索引
s.charAt(i)    s.length()// 长度   键盘录入字符串  Scanner sc = new Scanner(System.in);   String s = sc.next();
3.字符串的拼接
字符串可以拼接 用+就行，但字符串不能进行修改，每次都会创建一个新的对象
3.StrinBuilder：可以看成一个容器，创建之后里面的内容是可变的
getString()     substring()   replace()   length()   append()   insert()  reverse()
4.StringJoiner:可以方便高效的拼接字符串
StringJoiner sj = new StringJoiner(',', '[', ']');
sj.add('a').add('b').add('c');
sj.toString() == "[a,b,c]" 

ArrayList:
创建集合的对象   ArrayList<String> list = new ArrayList<>();
.add()    .remove(E e)/remove(index)  .get(index)  .size()   
基本数据类型的包装类：
byye-Byte  char-Character  int-Integer
ArrayList<Byte>  ArrayList<Character>   ArrayList<Integer> 

static:
静态随着类的加载而加载，静态与对象没有关系，所有对象共享，静态无法调用非静态，静态方法无法访问非静态，非静态方法可以访问所有，静态方法没有this关键字
多用于测试类和工具类，即与对象无关的类。一般类名调用，不用对象名调用。

多态的用处： 把子类对象赋值给父类引用，这样的好处是形参可以表示任意一个子类而无需对每个子类对象都重载方法
成员变量：编译看左边(父类)，运行也看左边(父类)
成员方法：编译看左边(父类)，运行看右边(子类)
多态的弊端，不能调用子类的特有方法，因为编译看左边(父类)，子类的特有方法没有被编译，也就无法运行

final关键字：
方法：表明该方法是最终方法， 不能被重写
类：表明该类是最终类，不能被继承
变量：叫做常量，只能被赋值一次

抽象类：
只要类里面存在一个及以上的抽象方法，那么这个类就要定义为抽象类
抽象方法继承后一定要重写
抽象类不能实例化 只能被继承
在类和方法的返回类型前面加一个abstract就行了

接口：
public interface Swim{}
一个类可以implements多个接口，必须重写接口里的所有方法
接口里的成员变量只能是常量：默认修饰符：public static final(可写可不写)
接口里没有构造方法
接口里的方法只能写抽象方法，public abstract(可写可不写)
多个接口中有重名的方法，只用重写一次就行了
接口和接口间是继承关系，可以多继承

内部类：
内部类可以直接调用外部类，而外部类调用内部类需要创建对象
匿名内部类：隐藏了名字的内部类
new 类名或者接口名（）{
   重写方法；
}
